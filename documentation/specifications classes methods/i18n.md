# Especificaciones de Clases y Métodos - i18n (Internacionalización)

## Objetivo

Este documento describe la configuración y uso de la internacionalización (i18n) en la aplicación "Touch the Mole". Incluye la configuración de Angular i18n, el uso de `$localize`, los archivos de traducción XLIFF, y cómo realizar pruebas con i18n.

## Ubicación de Archivos

- **Archivos de traducción**: `src/locale/`
  - `messages.es.xlf` - Traducciones en español
  - `messages.en.xlf` - Traducciones en inglés
- **Configuración de Angular**: `angular.json`
- **Configuración de aplicación**: `src/app/app.config.ts`
- **Declaración de tipos**: `global.d.ts`

---

## Configuración de i18n

### 1. Configuración en `angular.json`

#### Polyfills de Build

En la configuración de build, se incluye el polyfill de `@angular/localize`:

```json
"polyfills": [
  "zone.js",
  "@angular/localize/init"
]
```

**Propósito**: Inicializa la función global `$localize` necesaria para la internacionalización en tiempo de ejecución.

#### Configuraciones de Build Localizadas

La aplicación tiene tres configuraciones de producción:

1. **`production`**: Build sin localización específica
2. **`production-es`**: Build localizado para español
   ```json
   "localize": ["es"]
   ```
3. **`production-en`**: Build localizado para inglés
   ```json
   "localize": ["en"]
   ```

**Propósito**: Permite generar builds separados para cada idioma, optimizando el tamaño del bundle al incluir solo las traducciones necesarias.

#### Configuración de Tests

En la configuración de tests, también se incluye el polyfill:

```json
"test": {
  "options": {
    "polyfills": [
      "zone.js",
      "zone.js/testing",
      "@angular/localize/init"
    ]
  }
}
```

**Propósito**: Permite que los tests puedan usar `$localize` sin errores de "ReferenceError: $localize is not defined".

#### Builder de Extracción de i18n

```json
"extract-i18n": {
  "builder": "@angular/build:extract-i18n"
}
```

**Propósito**: Permite extraer todas las cadenas marcadas con `i18n` de los templates para generar o actualizar los archivos XLIFF.

**Uso**:
```bash
ng extract-i18n
```

---

### 2. Configuración en `app.config.ts`

#### Registro de Locales

```typescript
import localeEs from '@angular/common/locales/es';
import localeEn from '@angular/common/locales/en';

registerLocaleData(localeEs);
registerLocaleData(localeEn);
```

**Propósito**: Registra los datos de localización para español e inglés, permitiendo el formateo correcto de fechas, números y monedas según el locale.

#### Proveedor de LOCALE_ID

```typescript
{
  provide: LOCALE_ID,
  useValue: 'es',
}
```

**Propósito**: Establece el locale por defecto de la aplicación en español. Esto afecta el formateo de fechas, números y otras funciones dependientes del locale.

---

### 3. Declaración de Tipos en `global.d.ts`

```typescript
declare const $localize: {
  (messageParts: TemplateStringsArray, ...expressions: readonly unknown[]): string;
};
```

**Propósito**: 
- Declara la función global `$localize` para TypeScript
- Evita errores de compilación como `TS2304: Cannot find name '$localize'`
- Permite el uso de `$localize` en código TypeScript con tipado correcto

**Ubicación en tsconfig**: El archivo está incluido explícitamente en `tsconfig.json` mediante la propiedad `"files": ["global.d.ts"]`.

---

## Archivos de Traducción XLIFF

### Formato XLIFF 1.2

Los archivos de traducción utilizan el formato XLIFF 1.2 (XML Localization Interchange File Format), estándar de la industria para intercambio de traducciones.

### Estructura de un Archivo XLIFF

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2">
  <file source-language="es" datatype="plaintext" original="ng2.template">
    <body>
      <trans-unit id="app.title" datatype="html">
        <source>Toca el Topo</source>
        <target>Toca el Topo</target>
      </trans-unit>
    </body>
  </file>
</xliff>
```

### Elementos Clave

- **`trans-unit`**: Representa una unidad de traducción (una cadena de texto)
- **`id`**: Identificador único de la cadena (ej: `app.title`, `home.playerName.label`)
- **`source`**: Texto original en el idioma fuente
- **`target`**: Texto traducido al idioma objetivo

### IDs de Traducción en la Aplicación

La aplicación utiliza los siguientes IDs de traducción:

#### Página Home
- `@@app.title` - Título principal
- `@@home.playerName.label` - Etiqueta del campo de nombre
- `@@home.playerName.placeholder` - Placeholder del input
- `@@home.start.button` - Texto del botón de inicio

#### Página Game
- `@@game.difficulty.label` - Etiqueta del selector de dificultad
- `@@game.play.button` - Texto del botón de jugar
- `@@game.exit.button` - Texto del botón de salir
- `@@game.defaultPlayerName` - Nombre por defecto del jugador

#### Componente Score Board
- `@@scoreboard.player.label` - Etiqueta "Jugador"
- `@@scoreboard.points.label` - Etiqueta "Puntos"

#### Dificultades
- `@@difficulty.low` - Etiqueta "Bajo"
- `@@difficulty.medium` - Etiqueta "Medio"
- `@@difficulty.high` - Etiqueta "Alto"

---

## Uso de i18n en Templates HTML

### Directiva `i18n` para Contenido de Elementos

Para traducir el contenido de un elemento HTML:

```html
<h1 class="home__title" i18n="@@app.title">Toca el Topo</h1>
```

**Sintaxis**:
- `i18n="@@ID"` - Donde `ID` es el identificador único de la traducción
- El texto dentro del elemento es el texto por defecto (usado si no hay traducción disponible)

### Directiva `i18n-*` para Atributos

Para traducir atributos HTML específicos:

```html
<input
  type="text"
  i18n-placeholder="@@home.playerName.placeholder"
  placeholder="Tu nombre"
/>
```

**Sintaxis**:
- `i18n-{atributo}="@@ID"` - Donde `{atributo}` es el nombre del atributo a traducir
- Los atributos comunes incluyen: `placeholder`, `title`, `aria-label`, etc.

### Ejemplos en la Aplicación

#### Ejemplo 1: Título
```html
<h1 class="home__title" i18n="@@app.title">Toca el Topo</h1>
```

#### Ejemplo 2: Etiqueta y Placeholder
```html
<label class="home__field">
  <span class="home__label" i18n="@@home.playerName.label">
    Nombre del jugador
  </span>
  <input
    type="text"
    i18n-placeholder="@@home.playerName.placeholder"
    placeholder="Tu nombre"
  />
</label>
```

#### Ejemplo 3: Botón
```html
<button
  type="button"
  i18n="@@home.start.button"
>
  Start
</button>
```

---

## Uso de `$localize` en Código TypeScript

### Sintaxis de `$localize`

`$localize` es una función de tagged template que permite traducir cadenas en código TypeScript:

```typescript
$localize`:@@ID:Texto por defecto`
```

**Componentes**:
- `` `:@@ID:Texto por defecto` `` - Template literal con formato especial
- `:@@ID:` - Identificador de traducción (debe empezar y terminar con `:`)
- `Texto por defecto` - Texto que se usa si no hay traducción disponible

### Ejemplos en la Aplicación

#### Ejemplo 1: Etiquetas de Dificultad

```typescript
const difficultiesData: readonly Difficulty[] = [
  {
    id: DifficultyId.Low,
    label: $localize`:@@difficulty.low:Bajo`,
    multiplier: 1,
    intervalMs: 1000,
    points: 10,
  },
  {
    id: DifficultyId.Medium,
    label: $localize`:@@difficulty.medium:Medio`,
    multiplier: 2,
    intervalMs: 750,
    points: 20,
  },
  {
    id: DifficultyId.High,
    label: $localize`:@@difficulty.high:Alto`,
    multiplier: 3,
    intervalMs: 500,
    points: 30,
  },
];
```

**Ubicación**: `src/app/application/use-cases/difficulty.use-case.ts`

#### Ejemplo 2: Nombre por Defecto del Jugador

```typescript
export const startGame = (playerName: string, difficulty: Difficulty): GameState => {
  const sanitizedName = playerName.trim().slice(0, GAME_CONFIG.maxPlayerNameLength);
  const finalName = sanitizedName || $localize`:@@game.defaultPlayerName:Jugador`;
  
  return {
    playerName: finalName,
    points: 0,
    difficulty,
  };
};
```

**Ubicación**: `src/app/application/use-cases/start-game.use-case.ts`

### Características de `$localize`

- **Compilación en tiempo de build**: Las traducciones se resuelven durante la compilación
- **Type-safe**: TypeScript valida la sintaxis
- **Runtime fallback**: Si no hay traducción, usa el texto por defecto
- **Soporte de expresiones**: Permite interpolar valores en las traducciones

---

## Testing con i18n

### Problema Común: Atributos `i18n` no Disponibles en Tests

Durante las pruebas, los atributos `i18n` pueden no estar presentes en el DOM renderizado, ya que Angular los procesa durante la compilación y puede no preservarlos en el DOM durante las pruebas.

### Solución: Verificación Condicional

En lugar de verificar directamente el atributo `i18n`, se debe verificar de forma condicional:

#### Ejemplo 1: Verificación Condicional de Atributo i18n

```typescript
it('should have i18n attributes', () => {
  fixture.detectChanges();

  const title = fixture.nativeElement.querySelector('.home__title');
  const titleI18n = title.getAttribute('i18n');
  if (titleI18n !== null) {
    expect(titleI18n).toBe('@@app.title');
  }

  const label = fixture.nativeElement.querySelector('.home__label');
  const labelI18n = label.getAttribute('i18n');
  if (labelI18n !== null) {
    expect(labelI18n).toBe('@@home.playerName.label');
  }

  const button = fixture.nativeElement.querySelector('.home__button');
  const buttonI18n = button.getAttribute('i18n');
  if (buttonI18n !== null) {
    expect(buttonI18n).toBe('@@home.start.button');
  }
});
```

**Ubicación**: `src/app/presentation/pages/home/home.spec.ts`

**Ventajas**:
- El test no falla si el atributo no está presente
- Verifica el atributo cuando está disponible
- Es robusto ante cambios en cómo Angular procesa los atributos

#### Ejemplo 2: Verificación con Array de Elementos

```typescript
it('should have correct labels with i18n attributes', () => {
  fixture.detectChanges();

  const labels = fixture.nativeElement.querySelectorAll('.score-board__label');
  expect(labels.length).toBe(expectedStructure.labels.length);

  expectedStructure.labels.forEach((expectedLabel, index) => {
    const label = labels[index];
    expect(label).toBeTruthy();
    expect(label.textContent.trim()).toBe(expectedLabel.text);
    const i18nAttribute = label.getAttribute('i18n');
    if (i18nAttribute !== null) {
      expect(i18nAttribute).toBe(expectedLabel.i18n);
    }
  });
});
```

**Ubicación**: `src/app/presentation/components/score-board/score-board.spec.ts`

### Verificación del Texto Renderizado

Una alternativa más confiable es verificar el texto renderizado en lugar del atributo:

```typescript
it('should display translated text', () => {
  fixture.detectChanges();

  const title = fixture.nativeElement.querySelector('.home__title');
  expect(title.textContent.trim()).toBe('Toca el Topo');
  
  const label = fixture.nativeElement.querySelector('.home__label');
  expect(label.textContent.trim()).toBe('Nombre del jugador');
});
```

**Ventajas**:
- Verifica el resultado final (texto traducido)
- No depende de atributos que pueden no estar presentes
- Es más robusto y confiable

### Testing de `$localize` en Código TypeScript

Para probar código que usa `$localize`, se debe asegurar que el polyfill esté cargado:

#### Configuración Requerida

En `angular.json`, la configuración de tests debe incluir:

```json
"test": {
  "options": {
    "polyfills": [
      "zone.js",
      "zone.js/testing",
      "@angular/localize/init"
    ]
  }
}
```

#### Ejemplo de Test

```typescript
import { listDifficulties } from './difficulty.use-case';

describe('difficulty use cases', () => {
  it('should return difficulties with localized labels', () => {
    const difficulties = listDifficulties();
    
    expect(difficulties[0].label).toBeDefined();
    expect(difficulties[0].label).not.toBe('');
    
    expect(difficulties[1].label).toBeDefined();
    expect(difficulties[1].label).not.toBe('');
    
    expect(difficulties[2].label).toBeDefined();
    expect(difficulties[2].label).not.toBe('');
  });
});
```

**Nota**: En los tests, `$localize` puede retornar el texto por defecto o el texto traducido dependiendo de la configuración. Lo importante es verificar que el valor esté definido y no sea vacío.

### Mejores Prácticas para Testing con i18n

1. **Verificar el texto renderizado** en lugar de los atributos `i18n` cuando sea posible
2. **Usar verificación condicional** para atributos `i18n` si es necesario verificarlos
3. **Asegurar que el polyfill esté cargado** en la configuración de tests
4. **Probar el comportamiento**, no la implementación: verificar que el texto correcto se muestra, no necesariamente cómo se traduce
5. **Usar valores por defecto conocidos** en los tests para evitar dependencias de traducciones específicas

---

## Flujo de Trabajo con i18n

### 1. Desarrollo

1. Marcar cadenas en templates con `i18n="@@ID"`
2. Usar `$localize` en código TypeScript cuando sea necesario
3. Ejecutar `ng extract-i18n` para generar/actualizar archivos XLIFF

### 2. Traducción

1. Abrir archivos XLIFF en un editor de traducciones
2. Traducir los valores en `<target>` manteniendo los IDs
3. Guardar los archivos XLIFF

### 3. Build

1. **Build para desarrollo**: `ng build` (sin localización específica)
2. **Build para producción en español**: `ng build --configuration=production-es`
3. **Build para producción en inglés**: `ng build --configuration=production-en`

### 4. Testing

1. Los tests deben incluir el polyfill `@angular/localize/init`
2. Verificar texto renderizado en lugar de atributos cuando sea posible
3. Usar verificación condicional para atributos `i18n` si es necesario

---

## Comandos Útiles

### Extraer Cadenas para Traducción

```bash
ng extract-i18n
```

**Propósito**: Escanea todos los templates y código TypeScript, extrae las cadenas marcadas con `i18n` y `$localize`, y genera/actualiza los archivos XLIFF.

### Build Localizado

```bash
# Build para español
ng build --configuration=production-es

# Build para inglés
ng build --configuration=production-en
```

**Propósito**: Genera builds optimizados para cada idioma, incluyendo solo las traducciones necesarias.

### Servir con Localización

```bash
# Servir en español
ng serve --configuration=production-es

# Servir en inglés
ng serve --configuration=production-en
```

---

## Resolución de Problemas Comunes

### Error: "ReferenceError: $localize is not defined"

**Causa**: El polyfill `@angular/localize/init` no está incluido en la configuración.

**Solución**: Agregar `"@angular/localize/init"` a los polyfills en `angular.json`:
- En `build.options.polyfills`
- En `test.options.polyfills`

### Error: "TS2304: Cannot find name '$localize'"

**Causa**: Falta la declaración de tipos para `$localize`.

**Solución**: Asegurar que `global.d.ts` existe y está incluido en `tsconfig.json`.

### Atributos `i18n` no se encuentran en Tests

**Causa**: Angular puede no preservar los atributos `i18n` en el DOM durante las pruebas.

**Solución**: Usar verificación condicional o verificar el texto renderizado en lugar del atributo.

### Traducciones no se Aplican

**Causa**: 
- El build no está usando la configuración localizada correcta
- Los archivos XLIFF no están actualizados
- Los IDs de traducción no coinciden

**Solución**:
1. Verificar que se está usando la configuración correcta (`production-es` o `production-en`)
2. Ejecutar `ng extract-i18n` para actualizar los archivos XLIFF
3. Verificar que los IDs en templates y XLIFF coinciden exactamente

---

## Referencias

- [Angular i18n Documentation](https://angular.dev/guide/i18n)
- [XLIFF 1.2 Specification](http://docs.oasis-open.org/xliff/xliff-core/v1.2/os/xliff-core-v1.2-os.html)
- [Angular $localize API](https://angular.dev/api/localize/init/$localize)
